<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Phalanx CIWS Defense Simulator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* HUD Styling */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            user-select: none;
        }

        .panel {
            position: absolute;
            background: rgba(0, 20, 0, 0.6);
            border: 1px solid #0f0;
            padding: 15px;
            color: #0f0;
            border-radius: 4px;
        }

        #stats {
            top: 20px;
            left: 20px;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .toggle-btn {
            background: rgba(0, 20, 0, 0.6);
            border: 1px solid #0f0;
            padding: 10px 15px;
            color: #0f0;
            border-radius: 4px;
            cursor: pointer;
            pointer-events: auto;
            transition: background 0.3s;
            min-width: 150px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }

        .toggle-btn:hover {
            background: rgba(0, 40, 0, 0.8);
        }

        .toggle-btn.active {
            background: rgba(0, 60, 0, 0.8);
            border-color: #0ff;
            color: #0ff;
        }

        .toggle-btn.muted {
            background: rgba(60, 0, 0, 0.8);
            border-color: #f00;
            color: #f00;
        }

        #radar {
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: 2px solid #0f0;
            background: rgba(0, 20, 0, 0.8);
            position: absolute;
            overflow: hidden;
        }

        #radar-sweep {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(from 0deg, transparent 0deg, rgba(0, 255, 0, 0.5) 360deg);
            animation: sweep 2s linear infinite;
        }

        #center-reticle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 1px dashed rgba(0, 255, 0, 0.5);
            border-radius: 50%;
        }

        #game-over {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border: 2px solid red;
            pointer-events: auto;
            cursor: pointer;
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 24px;
            color: #fff;
            text-shadow: 0 0 5px #0f0;
        }

        .red-alert {
            color: #f00;
            animation: blink 0.5s infinite;
            display: none;
        }

        @keyframes sweep {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        @keyframes blink {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }

            100% {
                opacity: 1;
            }
        }
    </style>
</head>

<body>

    <div id="canvas-container"></div>

    <div id="hud">
        <div id="stats" class="panel">
            <div>STATUS: <span id="status-text">AUTO-ENGAGE</span></div>
            <div>WAVE: <span id="wave-count">1</span></div>
            <div>TARGETS DESTROYED: <span id="kill-count">0</span></div>
            <div>HIGH SCORE: <span id="high-score">0</span></div>
            <div>TIME ELAPSED: <span id="time-elapsed">00:00</span></div>
            <div>FRIENDLIES: <span id="friendly-count">0/0</span></div>
            <div>INTEGRITY: <span id="health-bar">100%</span></div>
        </div>

        <div id="controls">
            <div id="camera-toggle" class="toggle-btn" onclick="toggleCameraFollow()">
                <span>CAMERA FOLLOW</span>
                <span id="follow-status">OFF</span>
            </div>

            <div id="audio-toggle" class="toggle-btn muted" onclick="toggleMute()">
                <span>AUDIO</span>
                <span id="mute-status">OFF</span>
            </div>

            <div id="slowmo-toggle" class="toggle-btn" onclick="toggleSlowMo()">
                <span>SLOW MOTION</span>
                <span id="slowmo-status">OFF</span>
            </div>
        </div>

        <div id="center-reticle"></div>

        <div id="radar">
            <div id="radar-sweep"></div>
            <canvas id="radar-canvas" width="150" height="150"></canvas>
        </div>

        <div id="game-over">
            <h1 style="color:red">CRITICAL FAILURE</h1>
            <p id="game-over-reason">SYSTEM DESTROYED</p>
            <p>TARGETS DESTROYED: <span id="final-score">0</span></p>
            <p>TIME SURVIVED: <span id="final-time">00:00</span></p>
            <p>FRIENDLIES REMAINING: <span id="final-friendlies">0/0</span></p>
            <p>HIGH SCORE: <span id="final-high-score">0</span></p>
            <button onclick="location.reload()"
                style="padding: 10px 20px; background: #333; color: white; border: 1px solid white; cursor: pointer;">REBOOT
                SYSTEM</button>
        </div>
    </div>

    <!-- Load Three.js -->
    <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- CONFIGURATION ---
        const MISSILE_SPEED_BASE = 0.8;
        const BULLET_SPEED = 8.0;
        const GRAVITY = 0.02; // Gravity acceleration (units/frame²)
        const FIRE_RATE = 1; // Frames between shots (lower is faster)
        const ROTATION_SPEED = 0.15; // Turret traverse speed

        // --- NEW CONSTANTS ---
        const SIM_STEPS_PER_SECOND = 60;      // fixed reference rate
        const MAX_INTERCEPT_STEPS = 240;    // max allowed intercept time in sim-steps (~4 seconds)
        const YAW_FIRE_THRESHOLD = 0.10;   // radians (~5.7°)
        const PITCH_FIRE_THRESHOLD = 0.10;   // radians (~5.7°)
        const MAX_TRAVERSE_RATE = 0.08;   // max yaw/pitch change per step (radians/step)
const FRIENDLY_COUNT = 5;
const FRIENDLY_AREA = 100; // Half-size for 200x200 grid coverage

        // --- STATE ---
        let scene, camera, renderer, controls;
        let clock, deltaTime;
        let ciwsGroup, turretYaw, turretPitch, barrels;
        let projectiles = [];
        let missiles = [];
        let particles = [];
        let target = null;
        let lastFireTime = 0;
        let score = 0;
        let wave = 1;
        let health = 100;
        let isGameOver = false;
        let frameCount = 0;
        let missileSpawnRate = 120; // Frames between spawns
        let cameraMode = 0; // 0: OFF, 1: PHALANX, 2: MISSILE
        let cameraShake = 0;
        let startTime = 0;
        let elapsedTime = 0;
        let highScore = 0;
        let lastShake = { x: 0, y: 0 };
let friendlies = [];

        // Time Control
        let timeScale = 1.0;
        let fireCooldown = 0;
        let spawnCooldown = 0;
        let difficultyCooldown = 0;

        // --- AUDIO CONTROLLER ---
        const AudioController = {
            ctx: null,
            isInit: false,
            isMuted: true,
            masterGain: null,

            // Nodes
            motorOsc: null,
            motorGain: null,
            servoOsc: null,
            servoGain: null,
            gunOsc: null,
            gunNoise: null,
            gunGain: null,

            init: function () {
                if (this.isInit) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();

                this.masterGain = this.ctx.createGain();
                this.masterGain.connect(this.ctx.destination);

                // --- Motor Whine (High pitch turbine sound) ---
                this.motorOsc = this.ctx.createOscillator();
                this.motorOsc.type = 'sawtooth';
                this.motorOsc.frequency.value = 200;
                this.motorOsc.start();

                this.motorGain = this.ctx.createGain();
                this.motorGain.gain.value = 0;

                // Highpass to make it thin/whiny
                const motorFilter = this.ctx.createBiquadFilter();
                motorFilter.type = 'bandpass';
                motorFilter.frequency.value = 1000;
                motorFilter.Q.value = 1;

                this.motorOsc.connect(motorFilter);
                motorFilter.connect(this.motorGain);
                this.motorGain.connect(this.masterGain);

                // --- Servo Sound (Mechanical groaning) ---
                this.servoOsc = this.ctx.createOscillator();
                this.servoOsc.type = 'sawtooth'; // Sawtooth for grit
                this.servoOsc.frequency.value = 100;
                this.servoOsc.start();

                this.servoGain = this.ctx.createGain();
                this.servoGain.gain.value = 0;

                const servoFilter = this.ctx.createBiquadFilter();
                servoFilter.type = 'lowpass';
                servoFilter.frequency.value = 200;

                this.servoOsc.connect(servoFilter);
                servoFilter.connect(this.servoGain);
                this.servoGain.connect(this.masterGain);

                // --- Gun Sound (The RIP) ---
                // 1. Tonal component (The 75Hz hum/buzz of the shots)
                this.gunOsc = this.ctx.createOscillator();
                this.gunOsc.type = 'sawtooth';
                this.gunOsc.frequency.value = 75; // ~4500 RPM
                this.gunOsc.start();

                // 2. Noise component (The blast)
                const bufferSize = this.ctx.sampleRate * 2.0;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * 0.8;
                }
                this.gunNoise = this.ctx.createBufferSource();
                this.gunNoise.buffer = buffer;
                this.gunNoise.loop = true;
                this.gunNoise.start();

                this.gunGain = this.ctx.createGain();
                this.gunGain.gain.value = 0;

                // Mix both into gunGain
                this.gunOsc.connect(this.gunGain);
                this.gunNoise.connect(this.gunGain);

                // Compressor to glue it together and prevent clipping
                const compressor = this.ctx.createDynamicsCompressor();
                this.gunGain.connect(compressor);
                compressor.connect(this.masterGain);

                // Apply initial muted state
                if (this.isMuted) {
                    this.masterGain.gain.value = 0;
                }

                this.isInit = true;
                console.log("Audio Initialized");
            },

            toggleMute: function () {
                this.isMuted = !this.isMuted;
                if (this.masterGain) {
                    this.masterGain.gain.setTargetAtTime(this.isMuted ? 0 : 1, this.ctx.currentTime, 0.1);
                }
                return this.isMuted;
            },

            stopAll: function () {
                if (this.masterGain) {
                    this.masterGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.5);
                }
            },

            playExplosion: function (distance, timeScale) {
                if (!this.isInit || this.isMuted) return;

                // Speed of sound delay (approx 343 m/s)
                // In our sim, let's assume 1 unit = 1 meter for audio purposes
                const speedOfSound = 343 * timeScale; // Sound travels slower in slow mo? Or just delayed longer?
                // Actually, physics time is slower, so delay should be longer in wall-clock time.
                // delay = distance / speed. If speed is effectively same but time is slower, delay is longer.
                // Let's keep speed of sound constant in simulation units, but delay is in real seconds.
                // If 1 sim second = 10 real seconds, then delay is 10x.
                const delay = (distance / 343) / timeScale;

                setTimeout(() => {
                    if (this.isMuted) return; // Check again in case muted during delay

                    const t = this.ctx.currentTime;

                    // Create noise burst
                    // Duration is longer in slow mo
                    const dur = (0.5 + Math.random() * 0.5) / timeScale;
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sawtooth';

                    // Pitch is lower
                    const startFreq = 50 * timeScale;
                    const endFreq = 10 * timeScale;

                    osc.frequency.setValueAtTime(startFreq, t);
                    osc.frequency.exponentialRampToValueAtTime(endFreq, t + dur);

                    const noiseGain = this.ctx.createGain();

                    // Distance attenuation (Inverse square law approximation)
                    // Clamp distance to avoid infinite volume
                    const vol = Math.min(1.0, 50.0 / (distance + 10));

                    noiseGain.gain.setValueAtTime(vol, t);
                    noiseGain.gain.exponentialRampToValueAtTime(0.01, t + dur);

                    // Lowpass filter for distant explosions (muffling)
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    // Further away = lower cutoff
                    // Also scale cutoff by timeScale for muffled slow mo sound
                    const cutoff = Math.max(200, 20000 - (distance * 50)) * timeScale;
                    filter.frequency.setValueAtTime(cutoff, t);

                    osc.connect(filter);
                    filter.connect(noiseGain);
                    noiseGain.connect(this.masterGain);

                    osc.start(t);
                    osc.stop(t + dur);

                }, delay * 1000); // setTimeout uses ms
            },

            update: function (barrelSpeed, servoSpeed, isFiring, timeScale) {
                if (!this.isInit) return;
                const t = this.ctx.currentTime;

                // Motor
                // Pitch: 200Hz -> 800Hz (Scaled by timeScale)
                const motorFreq = (200 + (barrelSpeed * 600)) * timeScale;
                this.motorOsc.frequency.setTargetAtTime(motorFreq, t, 0.1);
                this.motorGain.gain.setTargetAtTime(barrelSpeed * 0.1, t, 0.1);

                // Servo
                const normalizedServo = Math.min(1.0, servoSpeed * 20); // Amplify small movements
                const servoFreq = (100 + (normalizedServo * 100)) * timeScale;
                this.servoOsc.frequency.setTargetAtTime(servoFreq, t, 0.1);
                this.servoGain.gain.setTargetAtTime(normalizedServo * 0.15, t, 0.1);

                // Gun
                const gunFreq = 75 * timeScale;
                this.gunOsc.frequency.setTargetAtTime(gunFreq, t, 0.1);
                // Playback rate for noise buffer (affects pitch of the blast)
                this.gunNoise.playbackRate.setTargetAtTime(timeScale, t, 0.1);

                if (isFiring) {
                    this.gunGain.gain.setTargetAtTime(0.4, t, 0.01);
                } else {
                    this.gunGain.gain.setTargetAtTime(0, t, 0.05);
                }
            }
        };

        // Audio State
        let currentBarrelSpeed = 0;
        let isFiring = false;

        // --- RADAR SETUP ---
        const radarCanvas = document.getElementById('radar-canvas');
        const radarCtx = radarCanvas.getContext('2d');

        function init() {
            // Load high score from localStorage
            const savedHighScore = localStorage.getItem('ciwsHighScore');
            if (savedHighScore) {
                highScore = parseInt(savedHighScore);
                document.getElementById('high-score').innerText = highScore;
            }

            // Initialize start time
            startTime = Date.now();

            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x4682b4); // Steel blue sky
            scene.fog = new THREE.FogExp2(0x87ceeb, 0.0005); // Light fog, much less dense

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(-15, 10, 20);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 5, 0); // Rotate around the top of the gun tower
            controls.enablePan = false;
            controls.maxDistance = 400;
            controls.minDistance = 5;
            controls.maxPolarAngle = Math.PI / 2 - 0.1; // Prevent going under water

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 3);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 3);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Environment (Ocean)
            const waterGeo = new THREE.PlaneGeometry(1000, 1000);
            const waterMat = new THREE.MeshPhongMaterial({
                color: 0x001e0f,
                shininess: 60,
                specular: 0x111111
            });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.rotation.x = -Math.PI / 2;
            water.receiveShadow = true;
            scene.add(water);

            // Grid helper for tactical look
            const gridHelper = new THREE.GridHelper(200, 50, 0x004400, 0x002200);
            scene.add(gridHelper);

            createPhalanxCIWS();
            createClouds();
            createMountains();
            createFriendlies();

            // Resize Handler
            window.addEventListener('resize', onWindowResize, false);

            // Start Loop
            clock = new THREE.Clock();

            // Initialize Audio on first interaction
            const startAudio = () => {
                AudioController.init();
                document.removeEventListener('mousedown', startAudio);
                document.removeEventListener('keydown', startAudio);
            };
            document.addEventListener('mousedown', startAudio);
            document.addEventListener('keydown', startAudio);

            animate();
        }

        function createPhalanxCIWS() {
            // 1. Static Base
            const baseGeo = new THREE.CylinderGeometry(2, 2.5, 3, 16);
            const greyMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.5 });
            const base = new THREE.Mesh(baseGeo, greyMat);
            base.position.y = 1.5;
            base.castShadow = true;
            scene.add(base);

            // 2. Yaw Group (Rotates Left/Right)
            ciwsGroup = new THREE.Group(); // The root anchor
            scene.add(ciwsGroup);

            turretYaw = new THREE.Group();
            turretYaw.position.y = 3;
            ciwsGroup.add(turretYaw);

            // Body of turret
            const bodyGeo = new THREE.BoxGeometry(2, 3, 2);
            const body = new THREE.Mesh(bodyGeo, greyMat);
            body.position.y = 1.5;
            body.castShadow = true;
            turretYaw.add(body);

            // 3. Pitch Group (The Gun Arms)
            turretPitch = new THREE.Group();
            turretPitch.position.set(0, 2, 0.5); // Pivot point
            turretYaw.add(turretPitch);

            // White Radome (The R2D2 looking top) - Now moves with gun
            const domeGeo = new THREE.CylinderGeometry(1.2, 1.2, 2.5, 16);
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            const dome = new THREE.Mesh(domeGeo, whiteMat);
            dome.position.y = 1.5; // Adjusted to be relative to pitch group
            dome.position.z = -0.5; // Adjusted to account for pitch pivot offset
            turretPitch.add(dome);

            // Radome Cap
            const capGeo = new THREE.SphereGeometry(1.2, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
            const cap = new THREE.Mesh(capGeo, whiteMat);
            cap.position.y = 2.75; // Adjusted to be relative to pitch group
            cap.position.z = -0.5; // Adjusted to account for pitch pivot offset
            turretPitch.add(cap);

            // Gun Block
            const gunBlockGeo = new THREE.BoxGeometry(1, 1, 3);
            const gunBlock = new THREE.Mesh(gunBlockGeo, greyMat);
            gunBlock.position.z = 1.5;
            turretPitch.add(gunBlock);

            // Barrels (The Vulcan cannon)
            barrels = new THREE.Group();
            for (let i = 0; i < 6; i++) {
                const barrelGeo = new THREE.CylinderGeometry(0.08, 0.08, 3.5, 8);
                const blackMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
                const barrel = new THREE.Mesh(barrelGeo, blackMat);
                const angle = (i / 6) * Math.PI * 2;
                barrel.position.x = Math.cos(angle) * 0.2;
                barrel.position.y = Math.sin(angle) * 0.2;
                barrel.position.z = 1.75; // extend out
                barrel.rotation.x = Math.PI / 2;
                barrels.add(barrel);
            }
            gunBlock.add(barrels); // Add barrels to gunblock, gunblock is in pitch group
        }

        function createClouds() {
            const cloudGeo = new THREE.SphereGeometry(1, 8, 8);
            const cloudMat = new THREE.MeshLambertMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                flatShading: true
            });

            for (let i = 0; i < 25; i++) {
                const cloudGroup = new THREE.Group();

                // Random position in sky
                const angle = Math.random() * Math.PI * 2;
                const dist = 200 + Math.random() * 200;
                const height = 60 + Math.random() * 60;

                cloudGroup.position.set(
                    Math.cos(angle) * dist,
                    height,
                    Math.sin(angle) * dist
                );

                // Create blobs for this cloud
                const blobs = 3 + Math.floor(Math.random() * 5);
                for (let j = 0; j < blobs; j++) {
                    const mesh = new THREE.Mesh(cloudGeo, cloudMat);
                    mesh.position.set(
                        (Math.random() - 0.5) * 15,
                        (Math.random() - 0.5) * 5,
                        (Math.random() - 0.5) * 10
                    );
                    const scale = 5 + Math.random() * 10;
                    mesh.scale.set(scale, scale * 0.6, scale);
                    cloudGroup.add(mesh);
                }

                cloudGroup.lookAt(0, height, 0); // Face center roughly
                scene.add(cloudGroup);
            }
        }

        function createMountains() {
            const mountainGeo = new THREE.ConeGeometry(1, 1, 4); // Low poly pyramid
            const mountainMat = new THREE.MeshLambertMaterial({
                color: 0x2a3a2a, // Dark green-grey
                flatShading: true
            });

            const count = 40;
            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const dist = 450 + Math.random() * 50;

                const mesh = new THREE.Mesh(mountainGeo, mountainMat);

                const w = 40 + Math.random() * 60;
                const h = 30 + Math.random() * 50;

                mesh.position.set(
                    Math.cos(angle) * dist,
                    h / 2 - 5, // Sink slightly
                    Math.sin(angle) * dist
                );

                mesh.scale.set(w, h, w);

                // Random rotation
                mesh.rotation.y = Math.random() * Math.PI;

                scene.add(mesh);
            }
        }

        function getAliveFriendliesCount() {
            return friendlies.reduce((count, f) => count + (f.alive ? 1 : 0), 0);
        }

        function updateFriendlyUI() {
            const alive = getAliveFriendliesCount();
            const total = friendlies.length;

            document.getElementById('friendly-count').innerText = `${alive}/${total}`;

            const finalFriendliesEl = document.getElementById('final-friendlies');
            if (finalFriendliesEl) {
                finalFriendliesEl.innerText = `${alive}/${total}`;
            }

            return alive;
        }

        function createFriendlies() {
            const friendlyGeo = new THREE.CylinderGeometry(0.8, 0.8, 1.5, 8);
            const halfArea = FRIENDLY_AREA;

            for (let i = 0; i < FRIENDLY_COUNT; i++) {
                const x = (Math.random() * 2 - 1) * halfArea;
                const z = (Math.random() * 2 - 1) * halfArea;

                const friendlyMat = new THREE.MeshPhongMaterial({
                    color: 0x0099ff,
                    emissive: 0x001133
                });

                const mesh = new THREE.Mesh(friendlyGeo, friendlyMat);
                mesh.position.set(x, 0.75, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);

                friendlies.push({
                    id: i,
                    mesh,
                    position: mesh.position.clone(),
                    alive: true
                });
            }

            updateFriendlyUI();
        }

        function pickTargetForIncoming() {
            const aliveFriendlies = friendlies.filter(f => f.alive);
            const targetCiws = Math.random() < 0.5 || aliveFriendlies.length === 0;

            if (targetCiws) {
                return { type: 'ciws', position: new THREE.Vector3(0, 2, 0) };
            }

            const choice = aliveFriendlies[Math.floor(Math.random() * aliveFriendlies.length)];
            return {
                type: 'friendly',
                position: choice.position.clone(),
                friendlyId: choice.id
            };
        }

        function spawnMissile() {
            const targetInfo = pickTargetForIncoming();
            const targetPos = targetInfo.position.clone();

            // Spawn randomly in the sky
            const angle = Math.random() * Math.PI * 2;

            // Determine if this is a mortar round (50% chance)
            const isMortar = Math.random() < 0.5;
            // Increase spawn distance by 50% for both mortars and missiles
            const distance = isMortar ? 900 : 600;

            let height, x, z;

            if (isMortar) {
                // Mortars spawn near ground level for high-arc trajectory
                height = 2 + Math.random() * 5;
                x = Math.cos(angle) * distance;
                z = Math.sin(angle) * distance;
            } else {
                // Regular missiles spawn at medium height
                height = 20 + Math.random() * 40;
                x = Math.cos(angle) * distance;
                z = Math.sin(angle) * distance;
            }

            // Model
            const geo = new THREE.CylinderGeometry(0.4, 0.8, 6, 8);
            geo.rotateX(Math.PI / 2); // Point forward
            // Mortars are darker colored
            const mat = new THREE.MeshPhongMaterial({ color: isMortar ? 0x884400 : 0xaa0000 });
            const missile = new THREE.Mesh(geo, mat);

            missile.position.set(x, height, z);

            let velocity;
            if (isMortar) {
                // Calculate 45-degree high-angle ballistic arc trajectory that hits the target
                const toTarget = targetPos.clone().sub(missile.position);
                const horizontalDist = Math.sqrt(toTarget.x * toTarget.x + toTarget.z * toTarget.z);
                const heightDiff = missile.position.y - targetPos.y; // positive if mortar is above target
                
                // For projectile motion with launch angle θ = 45°:
                // v² = g * x² / (x + y0 - yTarget)  where x is horizontal dist
                // This solves the ballistic equations to hit the exact target
                const denominator = horizontalDist + heightDiff;
                
                // Ensure we have a valid trajectory (denominator must be positive)
                let launchSpeed;
                if (denominator > 10) {
                    launchSpeed = Math.sqrt(GRAVITY * horizontalDist * horizontalDist / denominator);
                } else {
                    // Fallback for edge cases - use a reasonable arc speed
                    launchSpeed = Math.sqrt(horizontalDist * GRAVITY * 2);
                }
                
                // At 45 degrees, horizontal and vertical components are equal
                const cos45 = Math.cos(Math.PI / 4); // ≈ 0.707
                const sin45 = Math.sin(Math.PI / 4); // ≈ 0.707
                const horizontalSpeed = launchSpeed * cos45;
                const verticalSpeed = launchSpeed * sin45;
                
                // Direction towards target (horizontal only)
                const horizontalDir = new THREE.Vector3(toTarget.x, 0, toTarget.z).normalize();
                
                velocity = horizontalDir.multiplyScalar(horizontalSpeed);
                velocity.y = verticalSpeed;

                missile.lookAt(missile.position.clone().add(velocity));
            } else {
                // Regular missile - straight line to target
                missile.lookAt(targetPos);
                velocity = new THREE.Vector3().subVectors(targetPos, missile.position).normalize().multiplyScalar(MISSILE_SPEED_BASE + (wave * 0.05));
            }

            // Add simple engine glow (dimmer for mortars)
            const glowGeo = new THREE.SphereGeometry(0.3);
            const glowMat = new THREE.MeshBasicMaterial({ color: isMortar ? 0xaa6600 : 0xffaa00 });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            glow.position.z = -1.5;
            missile.add(glow);

            scene.add(missile);

            missiles.push({
                mesh: missile,
                velocity: velocity,
                health: 2,
                isMortar: isMortar,
                targetInfo,
                eta: null
            });
        }

        function createExplosion(position, size) {
            // Audio: Calculate distance to camera/player (at 0,0,0 roughly)
            const dist = position.distanceTo(camera.position);
            AudioController.playExplosion(dist, timeScale);

            const particleCount = 15;
            for (let i = 0; i < particleCount; i++) {
                const geo = new THREE.BoxGeometry(size, size, size);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(position);

                // Random velocity
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 1,
                    (Math.random() - 0.5) * 1,
                    (Math.random() - 0.5) * 1
                );

                scene.add(mesh);
                particles.push({ mesh: mesh, velocity: vel, life: 1.0 });
            }
        }

        function shoot() {
            // Muzzle flash location (approximate end of barrels)
            const muzzlePos = new THREE.Vector3(0, 0, 3.5);
            muzzlePos.applyMatrix4(barrels.matrixWorld);

            // Create Tracer
            const geo = new THREE.BoxGeometry(0.1, 0.1, 2);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(geo, mat);

            bullet.position.copy(muzzlePos);

            // Slight spread
            const spread = 0.0125;
            bullet.quaternion.copy(turretPitch.getWorldQuaternion(new THREE.Quaternion()));
            bullet.rotateX((Math.random() - 0.5) * spread);
            bullet.rotateY((Math.random() - 0.5) * spread);

            scene.add(bullet);

            // Calculate velocity vector based on rotation
            const velocity = new THREE.Vector3(0, 0, 1);
            velocity.applyQuaternion(bullet.quaternion);
            velocity.multiplyScalar(BULLET_SPEED);

            projectiles.push({
                mesh: bullet,
                velocity: velocity.clone(), // Current velocity (will be affected by gravity)
                life: 60
            });

            if (cameraMode === 1) cameraShake = 0.3;
        }

        function updateRadar() {
            radarCtx.clearRect(0, 0, 150, 150);
            const center = 75;
            const scale = 0.1; // Scale world coords to radar (quadrupled range - lower scale = longer range)

            radarCtx.fillStyle = '#0f0';
            radarCtx.fillRect(center - 2, center - 2, 4, 4); // Player

            radarCtx.fillStyle = '#0ff';
            friendlies.forEach(f => {
                if (!f.alive) return;
                const x = center + (f.position.x * scale);
                const y = center + (f.position.z * scale);
                const d = Math.sqrt(Math.pow(x - center, 2) + Math.pow(y - center, 2));
                if (d < 75) {
                    radarCtx.fillRect(x - 2, y - 2, 4, 4);
                }
            });

            radarCtx.fillStyle = '#f00';
            missiles.forEach(m => {
                const x = center + (m.mesh.position.x * scale);
                const y = center + (m.mesh.position.z * scale);

                // Only draw if inside circle
                const d = Math.sqrt(Math.pow(x - center, 2) + Math.pow(y - center, 2));
                if (d < 75) {
                    radarCtx.beginPath();
                    radarCtx.arc(x, y, 2, 0, Math.PI * 2);
                    radarCtx.fill();
                }
            });
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function solveInterceptSteps(D, V, bulletSpeed) {
            // D: THREE.Vector3 from muzzle to target (position difference)
            // V: THREE.Vector3 target velocity (per step)
            // bulletSpeed: scalar, bullet speed (per step)
            //
            // Returns:
            //   t (number of simulation steps) if a valid positive solution ≤ MAX_INTERCEPT_STEPS exists,
            //   null otherwise.

            const S = bulletSpeed;

            const a = V.lengthSq() - S * S;
            const b = 2 * D.dot(V);
            const c = D.lengthSq();

            let t = null;

            if (Math.abs(a) < 1e-6) {
                // Degenerate to linear: b * t + c = 0
                if (Math.abs(b) > 1e-6) {
                    const tLin = -c / b;
                    if (tLin > 0 && tLin <= MAX_INTERCEPT_STEPS) {
                        t = tLin;
                    }
                }
            } else {
                const delta = b * b - 4 * a * c;
                if (delta >= 0) {
                    const sqrtDelta = Math.sqrt(delta);
                    const t1 = (-b - sqrtDelta) / (2 * a);
                    const t2 = (-b + sqrtDelta) / (2 * a);

                    const candidates = [];
                    if (t1 > 0) candidates.push(t1);
                    if (t2 > 0) candidates.push(t2);

                    if (candidates.length > 0) {
                        const tCandidate = Math.min(...candidates);
                        if (tCandidate <= MAX_INTERCEPT_STEPS) {
                            t = tCandidate;
                        }
                    }
                }
            }

            return t;
        }

        function estimateTimeToImpact(missile) {
            const speed = missile.velocity.length();
            if (speed < 1e-4) return Infinity;
            const dist = missile.mesh.position.distanceTo(missile.targetInfo.position);
            return dist / speed;
        }

        function triggerGameOver(reason) {
            if (isGameOver) return;

            isGameOver = true;

            const statusText = document.getElementById('status-text');
            if (statusText) {
                statusText.style.color = "red";
                statusText.innerText = reason === 'friendlies' ? 'FRIENDLIES LOST' : 'SYSTEM OFFLINE';
            }

            const reasonText = reason === 'friendlies' ? 'ALL FRIENDLIES DESTROYED' : 'SYSTEM DESTROYED';
            const gameOverReason = document.getElementById('game-over-reason');
            if (gameOverReason) {
                gameOverReason.innerText = reasonText;
            }

            updateFriendlyUI();

            AudioController.stopAll();

            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').innerText = score;
            document.getElementById('final-time').innerText = formatTime(elapsedTime);
            document.getElementById('final-high-score').innerText = highScore;
        }

        function updateLogic(simSteps) {
            if (isGameOver) return;

            // Update elapsed time (scaled to real seconds, same as before)
            elapsedTime += deltaTime * timeScale;
            document.getElementById('time-elapsed').innerText = formatTime(elapsedTime);

            // 1. Manage Missiles
            spawnCooldown -= simSteps;
            if (spawnCooldown <= 0) {
                spawnMissile();
                spawnCooldown = missileSpawnRate;
            }

            // Difficulty ramp
            difficultyCooldown -= simSteps;
            if (difficultyCooldown <= 0) {
                wave++;
                missileSpawnRate = Math.max(20, 120 - (wave * 5));
                document.getElementById('wave-count').innerText = wave;
                difficultyCooldown = 1000; // Reset for next wave
            }



            // Find target (choose earliest impact; break ties toward friendlies)
            let bestTarget = null;
            const etaEpsilon = 1e-3;

            for (let i = missiles.length - 1; i >= 0; i--) {
                const m = missiles[i];

                // Move Missile first (using current velocity)
                m.mesh.position.addScaledVector(m.velocity, simSteps);

                // Then apply gravity to mortar rounds for next frame
                if (m.isMortar) {
                    m.velocity.y -= GRAVITY * simSteps;
                }

                // Update orientation based on type
                if (m.isMortar) {
                    // Mortars point along their velocity vector (ballistic arc)
                    const lookTarget = m.mesh.position.clone().add(m.velocity.clone().normalize());
                    m.mesh.lookAt(lookTarget);
                } else {
                    // Regular missiles point toward their assigned target
                    m.mesh.lookAt(m.targetInfo.position);
                }

                const distToTarget = m.mesh.position.distanceTo(m.targetInfo.position);
                
                // For mortars, also check horizontal distance and if below target height
                // This catches mortars that pass through on steep descent
                const horizontalDist = Math.sqrt(
                    Math.pow(m.mesh.position.x - m.targetInfo.position.x, 2) +
                    Math.pow(m.mesh.position.z - m.targetInfo.position.z, 2)
                );
                const passedThroughTarget = m.isMortar && 
                    horizontalDist < 8 && 
                    m.mesh.position.y < m.targetInfo.position.y + 2;

                // Impact Check
                if (distToTarget < 5 || passedThroughTarget) {
                    createExplosion(m.mesh.position, 1);
                    scene.remove(m.mesh);
                    missiles.splice(i, 1);
                    if (m.targetInfo.type === 'ciws') {
                        health = Math.max(0, health - 25);
                        document.getElementById('health-bar').innerText = `${health}%`;
                        if (health <= 0) {
                            triggerGameOver('ciws');
                        }
                    } else if (m.targetInfo.type === 'friendly') {
                        const f = friendlies.find(fr => fr.id === m.targetInfo.friendlyId);
                        if (f && f.alive) {
                            f.alive = false;
                            scene.remove(f.mesh);

                            const remainingFriendlies = updateFriendlyUI();
                            if (remainingFriendlies === 0) {
                                triggerGameOver('friendlies');
                            }
                        }
                    }
                    continue;
                }

                const eta = estimateTimeToImpact(m);
                const priority = m.targetInfo.type === 'friendly' ? 1 : 0; // prefer friendly on tie

                if (!bestTarget ||
                    eta < bestTarget.eta - etaEpsilon ||
                    (Math.abs(eta - bestTarget.eta) <= etaEpsilon && priority > bestTarget.priority)) {
                    bestTarget = { missile: m, eta, priority };
                }
            }

            target = bestTarget ? bestTarget.missile : null;

            // 2. Turret Tracking
            let servoSpeed = 0;
            isFiring = false;

            if (target) {
                // Calculate Yaw (Left/Right)
                const targetPos = target.mesh.position.clone();

                // Get actual muzzle position (where bullets spawn from)
                const muzzlePos = new THREE.Vector3(0, 0, 3.5);
                muzzlePos.applyMatrix4(barrels.matrixWorld);

                const D = targetPos.clone().sub(muzzlePos);
                const V = target.velocity.clone();      // per-step velocity
                const S = BULLET_SPEED;                 // per-step bullet speed

                let aimPoint = null;
                let interceptSteps = null;

                if (target.isMortar) {
                    interceptSteps = solveInterceptSteps(D, V, S);
                    if (interceptSteps !== null) {
                        aimPoint = targetPos.clone().addScaledVector(V, interceptSteps);
                    } else {
                        // Fallback: aim at current position if no valid solution
                        aimPoint = targetPos;
                    }
                } else {
                    interceptSteps = solveInterceptSteps(D, V, S);

                    if (interceptSteps !== null) {
                        // Predicted missile position ignoring gravity
                        const predictedPos = targetPos.clone().addScaledVector(V, interceptSteps);

                        // Bullet drop over 'interceptSteps' when subject to GRAVITY per step and
                        // starting with the current muzzle velocity.
                        //
                        // Vertical displacement due to constant acceleration:
                        //   drop = 0.5 * GRAVITY * t^2
                        //
                        // Here t = interceptSteps (in sim-steps).
                        const bulletDrop = 0.5 * GRAVITY * interceptSteps * interceptSteps;

                        // Aim above predicted missile position by 'bulletDrop'
                        aimPoint = predictedPos.clone();
                        aimPoint.y += bulletDrop;
                    } else {
                        // Fallback: aim at current position if no valid solution
                        aimPoint = targetPos;
                    }
                }

                // Compute local vector from muzzle to aimPoint
                const localTarget = aimPoint.clone().sub(muzzlePos);

                const targetYaw = Math.atan2(localTarget.x, localTarget.z);
                const xzDist = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);
                const targetPitch = -Math.atan2(localTarget.y, xzDist);

                // Yaw traverse with clamped rate
                const currentYaw = turretYaw.rotation.y;
                let yawDiff = targetYaw - currentYaw;

                // Normalize to [-π, π]
                while (yawDiff > Math.PI) yawDiff -= 2 * Math.PI;
                while (yawDiff < -Math.PI) yawDiff += 2 * Math.PI;

                const yawStep = THREE.MathUtils.clamp(
                    yawDiff,
                    -MAX_TRAVERSE_RATE * simSteps,
                    +MAX_TRAVERSE_RATE * simSteps
                );

                turretYaw.rotation.y = currentYaw + yawStep;

                // Pitch traverse with clamped rate
                const currentPitch = turretPitch.rotation.x;
                const pitchDiff = targetPitch - currentPitch;

                const pitchStep = THREE.MathUtils.clamp(
                    pitchDiff,
                    -MAX_TRAVERSE_RATE * simSteps,
                    +MAX_TRAVERSE_RATE * simSteps
                );

                turretPitch.rotation.x = currentPitch + pitchStep;

                // Compute angular error magnitudes for gating and servo audio
                const yawError = Math.abs(yawDiff);
                const pitchError = Math.abs(pitchDiff);
                const servoSpeedVal = Math.abs(yawStep) + Math.abs(pitchStep); // Use local var to avoid conflict if any

                // Spin Barrels
                currentBarrelSpeed = Math.min(1.0, currentBarrelSpeed + 0.05 * simSteps);
                barrels.rotation.z += currentBarrelSpeed * simSteps;

                // Fire gating based on yaw & pitch and intercept validity
                fireCooldown -= simSteps;
                isFiring = false;

                // Only fire when:
                //  - we have a valid interceptSteps
                //  - angular errors are small
                //  - cooldown expired
                if (interceptSteps !== null &&
                    yawError < YAW_FIRE_THRESHOLD &&
                    pitchError < PITCH_FIRE_THRESHOLD &&
                    fireCooldown <= 0) {

                    shoot();
                    isFiring = true;
                    fireCooldown = FIRE_RATE;    // FIRE_RATE is in sim-steps
                }

                // Update servoSpeed for audio
                servoSpeed = servoSpeedVal;

            } else {
                // Spin down when idle
                currentBarrelSpeed = Math.max(0, currentBarrelSpeed - 0.02 * simSteps);
                barrels.rotation.z += currentBarrelSpeed * simSteps;
                isFiring = false;

                // Audio update handled below, servoSpeed is 0
            }

            AudioController.update(currentBarrelSpeed, servoSpeed, isFiring, timeScale);

            // 3. Projectiles & Collision
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.life -= simSteps;
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                    continue;
                }

                const prevPos = p.mesh.position.clone();

                // Apply gravity to velocity
                p.velocity.y -= GRAVITY * simSteps;

                // Update position
                p.mesh.position.addScaledVector(p.velocity, simSteps);

                // Check collision with missiles
                // Raycast approximation for high speed
                const travelVec = p.mesh.position.clone().sub(prevPos);
                const ray = new THREE.Ray(prevPos, travelVec.clone().normalize());
                const travelDist = travelVec.length();

                let hit = false;
                for (let j = missiles.length - 1; j >= 0; j--) {
                    const m = missiles[j];
                    const mPos = m.mesh.position;

                    // Simple sphere check first
                    if (mPos.distanceTo(p.mesh.position) < 3.0) {
                        // More precise check not strictly needed for arcade feel, 
                        // but let's check distance to ray
                        const distToRay = ray.distanceSqToPoint(mPos);
                        if (distToRay < 1.0) {
                            // HIT
                            createExplosion(mPos, 0.5);
                            m.health--;

                            // Remove bullet
                            scene.remove(p.mesh);
                            projectiles.splice(i, 1);
                            hit = true;

                            if (m.health <= 0) {
                                createExplosion(mPos, 2.0);
                                scene.remove(m.mesh);
                                missiles.splice(j, 1);
                                score++;
                                document.getElementById('kill-count').innerText = score;

                                // Update high score if beaten
                                if (score > highScore) {
                                    highScore = score;
                                    localStorage.setItem('ciwsHighScore', highScore);
                                    document.getElementById('high-score').innerText = highScore;
                                }
                            }
                            break;
                        }
                    }
                }
                if (hit) continue;
            }

            // 4. Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const part = particles[i];
                part.mesh.position.addScaledVector(part.velocity, simSteps);
                part.mesh.material.opacity = part.life;
                part.mesh.material.transparent = true;
                part.life -= 0.05 * simSteps;
                if (part.life <= 0) {
                    scene.remove(part.mesh);
                    particles.splice(i, 1);
                }
            }
        }

        function toggleCameraFollow() {
            cameraMode = (cameraMode + 1) % 3;
            const toggleBtn = document.getElementById('camera-toggle');
            const statusText = document.getElementById('follow-status');

            if (cameraMode === 1) {
                toggleBtn.classList.add('active');
                statusText.innerText = 'PHALANX';
                controls.enabled = false;
            } else if (cameraMode === 2) {
                toggleBtn.classList.add('active');
                statusText.innerText = 'MISSILE';
                controls.enabled = false;
            } else {
                toggleBtn.classList.remove('active');
                statusText.innerText = 'OFF';
                controls.enabled = true;
            }
        }

        function toggleMute() {
            const isMuted = AudioController.toggleMute();
            const toggleBtn = document.getElementById('audio-toggle');
            const statusText = document.getElementById('mute-status');

            if (isMuted) {
                toggleBtn.classList.add('muted');
                statusText.innerText = 'OFF';
            } else {
                toggleBtn.classList.remove('muted');
                statusText.innerText = 'ON';
            }
        }

        function toggleSlowMo() {
            const toggleBtn = document.getElementById('slowmo-toggle');
            const statusText = document.getElementById('slowmo-status');

            if (timeScale === 1.0) {
                timeScale = 0.1;
                toggleBtn.classList.add('active');
                statusText.innerText = 'ON';
            } else {
                timeScale = 1.0;
                toggleBtn.classList.remove('active');
                statusText.innerText = 'OFF';
            }
        }

        // Expose to global scope for onclick handler
        window.toggleCameraFollow = toggleCameraFollow;
        window.toggleMute = toggleMute;
        window.toggleSlowMo = toggleSlowMo;

        function updateCameraFollow() {
            if (cameraMode === 0) return;

            // --- MODE 1: PHALANX FOLLOW ---
            if (cameraMode === 1) {
                if (!turretPitch || !turretYaw) return;

                // Apply Rotational Shake to the GUN
                if (cameraShake > 0) {
                    const shakeIntensity = 0.0125; // Radians
                    const rx = (Math.random() - 0.5) * cameraShake * shakeIntensity;
                    const ry = (Math.random() - 0.5) * cameraShake * shakeIntensity;

                    turretPitch.rotation.x += rx;
                    turretPitch.rotation.y += ry;

                    lastShake.x = rx;
                    lastShake.y = ry;

                    cameraShake *= (1 - (0.15 * timeScale)); // Decay scaled by time
                }

                // Gunsight camera: positioned next to the gun barrels, pointing parallel
                const gunPos = new THREE.Vector3();
                turretPitch.getWorldPosition(gunPos);

                const gunQuaternion = new THREE.Quaternion();
                turretPitch.getWorldQuaternion(gunQuaternion);

                // Action camera: "Over the shoulder" view
                const offset = new THREE.Vector3(4.0, 2.5, -6.0);
                offset.applyQuaternion(gunQuaternion);

                camera.position.copy(gunPos).add(offset);
                camera.quaternion.copy(gunQuaternion);
                camera.rotateY(Math.PI);
            }

            // --- MODE 2: MISSILE FOLLOW ---
            else if (cameraMode === 2) {
                // If no target, fallback to a "Searching" view (high up, looking at Phalanx)
                // Or just stick to the last known position? 
                // Let's do a high-up view of the base if no target.
                if (!target) {
                    // Smoothly move to a default overview position?
                    // For now, let's just snap to a "Waiting" view
                    const defaultPos = new THREE.Vector3(20, 20, 20);
                    camera.position.lerp(defaultPos, 0.1);
                    camera.lookAt(0, 5, 0);
                    return;
                }

                // Target exists - track it
                const tPos = target.mesh.position.clone();
                const phalanxPos = new THREE.Vector3(0, 2, 0);

                // Calculate direction FROM target TO Phalanx
                const toPhalanx = new THREE.Vector3().subVectors(phalanxPos, tPos).normalize();

                // Position camera "over the shoulder"
                // We want to be behind the missile (further away from Phalanx) and slightly up
                // "Behind" means -toPhalanx direction
                const camOffset = toPhalanx.clone().multiplyScalar(-8); // 8 units behind
                camOffset.y += 3; // 3 units up

                const camPos = tPos.clone().add(camOffset);

                // Smoothly update camera position
                camera.position.lerp(camPos, 0.2); // Smooth follow

                // Look at Phalanx
                camera.lookAt(phalanxPos);
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            // Revert shake from previous frame so logic/aiming is clean
            if (turretPitch) {
                turretPitch.rotation.x -= lastShake.x;
                turretPitch.rotation.y -= lastShake.y;
                lastShake = { x: 0, y: 0 };
            }

            deltaTime = clock.getDelta();
            const realDt = deltaTime; // seconds (real)
            const simSteps = realDt * SIM_STEPS_PER_SECOND * timeScale; // simulation steps for this frame

            frameCount++;

            updateLogic(simSteps);
            updateRadar();
            updateCameraFollow();

            if (cameraMode === 0) {
                controls.update();
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Init
        init();

    </script>
</body>

</html>